\section{Desarrollo}
\subsection{WebServer}

Para poder realizar las conexiones mediante pagina web para realizar control de manera remota se opto por utilizar Django como marco de trabajo ya que facilita la administracion de la pagina en base a un template, ademas esta permite realizar conexiones asincronas de tipo websocket mediante el uso de Django channels.
Django se instala con pip install django y django channels con pip install channels, una vez instalado se corre el comando django-admin startproject nombre-del-servidor, lo cual creara una carpeta con los archivos que Django requiere para funcionar.

una vez que el servidor esta creado dentro de la carpeta de django esta el archivo manage.py, este se utiliza para manejar la pagina web, primero se debe crear la aplicacion a usar mediante el comando python manage.py nombre-app

en la carpeta de django se encuentra una carpeta con el server y otra con la aplicacion, ademas hay que crear una carpeta llamada template con un archivo .html que servirta de base para la pagina web, en este hay que agregar la estructura de la pagina y las funciones de comunicacion mediante websocket que se ejecutaran por parte del cliente

en la carpeta del server se debe entrar en config.py y agregar en INSTALLED\_APPS channels y la app creada, para permitir conerxiones externas estas se deben permitir en ALLOWED mediante '*' para aceptar todas las conexiones
Comunicacion asgi se debe agregar ASGI\_APPLICATION = 'webserver\_rp.asgi.application' y crear el archivo asgi.py (agregar codigo)

para el uso del template se debe agregar en config.py la opcion TEMPLATES (poner codigo) y finalmente para permitir que el websocket del servidor envie mensajes a todos los clientes se debe agregar la opcion CHANNEL\_LAYERS (agregar codigo).

en urls se debe agregar el archivo urls de la aplicacion (ver codigo urls.py)

en la carpeta de la aplicacion se debe modificar el archivo views para que se renderize la pagina a partir del template, el archivo urls para que incluya el template en la url por defecto, en routing se agrega una ruta para la conexion websocket y se importa el archivo consumers (ver codigo), en el archivo consumers se encuentra la funcionalidad del websocket, se puede configurar de distintas maneras, en este caso se configuro de manera asincrona, para poder realizar el envio de mensajes masivo se crea la funcion broadcast\_send

en la funcion connect se crean los estados base en la primera conexion y en las siguientes solo se les envia el estado actual, ademas se les asigna el grupo para el envio de mesages masivo

en la funcion receive cada vez que el servidor recibe un mensaje de los clientes modifica los estados de las luces o el motor segun el mensaje, una vez modificado transmite los estados a todos los clientes y hace un print de el estado modificado (para efectos de debug.)


\subsection{control}
en el archivo en raiz controlador.py se tiene el control de las salidas y las entradas mediante botones, ya que el sistema funciona con websocket asincronos aqui se usa la libreria websockets, instalada mediante pip install websockets, para recibir las instrucciones y enviar los cambios.

empezando por los botones, estos se encuentran en la clase control\_programa, la cual al iniciarce define cuales seran los botones de entrada e incluye la funcion asincrona para enviar mensajes adecuados cada vez que se pulse un boton.


La funcion salidas maneja los output del sistema, al iniciarce define cuales son los pines de output, 4 son para manejar el motor paso a paso y 2 para las luces, ademas recibe el estado actual que indica el servidor, ses funciones son cambiar\_luces para cambiar el estado de las luces, control\_motor revisa el estado que se indica que debe tener el motor, si este cambia se aplica el algoritmo para abrir o cerrar, si es parar se ponen en 0 todas las salidas del motor, la ultima funcion es recibir\_instrucciones, la cual aguarda a un mensaje del servidor para cambiar los estados, igual aplica los cambios en las luces cuando recibe un nuevo estado de las luces.

Finalmente esto se encapsula en la funcion use\_ws la cual genera la conexion con el websocket, inicia las clases y lanza en paralelo las funciones para enviar cambios al servidor, recibir datos del servidor y controlar los motores (recordar que el cambio de luz se encuentra en recibir datos)

en caso de que no se encuentre disponible el servidor seguira intentando conectarse

\subsection{Hardware}

foto del sistema